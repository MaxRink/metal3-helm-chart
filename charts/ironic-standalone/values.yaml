ironicServerName: DEFINE-SERVER-NAME.IO-OR-EXTERNAL-IP

## Ironic container image used for all Ironic components
##
image:
  name: artifactory.tools.in.pan-net.eu/s_nfvi_caas-images-docker-local/ironic-standalone
  version: wallaby
  pullPolicy: IfNotPresent

## Existing persistent volume claim
## make sure the pvc can be cross mounted between the containers
# persistentVolumeClaimName: DEFINE-EXISTING-PV-CLAIM

## /etc/ironic/policy.json contents
##
policy_json: ""

## BasicAuth Config 
basicAuth:
  ## Credentials for HTTP BASIC AUTH
  credentials: 
## - username: test
##   password: test
##

## _Some_ of the /etc/ironic/ironic.conf
## configuration options.
## If you need more, please extract and create PR.
##
config:
  DEFAULT:
    debug: true
    enabled_hardware_types: redfish,ilo5,ilo
    enabled_boot_interfaces: ilo-uefi-https,ilo-virtual-media,redfish-virtual-media
    #default_boot_interface: ilo-virtual-media
    enabled_network_interfaces: noop
    enabled_management_interfaces: ilo5,ilo,redfish
    enabled_power_interfaces: ilo,redfish
    enabled_raid_interfaces: ilo5,no-raid
    default_raid_interface: no-raid
    enabled_deploy_interfaces: direct
    default_deploy_interface: direct
    enabled_inspect_interfaces: ilo,redfish,inspector
    #default_inspect_interface: ilo
    enabled_console_interfaces: no-console
    enabled_bios_interfaces: no-bios
    grub_config_path: /EFI/BOOT/grub.cfg
  keystone_authtoken: {}
  api:
    api_workers: 8
  conductor:
    heartbeat_interval: 10
    heartbeat_timeout: 30
    deploy_callback_timeout: 1800
    power_state_sync_max_retries: 3
    #automated_clean: false
    clean_callback_timeout: 1800
  database: {}
  deploy:
    enable_ata_secure_erase: true
    #erase_devices_priority: 0
    #erase_devices_metadata_priority: 0
    power_off_after_deploy_failure: false
    http_root: /storage/httpboot
  dhcp:
    dhcp_provider: none
  ilo:
    verify_ca: false
    default_boot_mode: uefi
    kernel_append_params: ipa-insecure=1 ipa-debug=1 
  redfish:
    kernel_append_params: ipa-insecure=1 ipa-debug=1
  pxe:
    images_path: /storage/httpboot/images
    instance_master_path: /storage/httpboot/master-path
    tftp_root: /storage/tftpboot
    tftp_master_path: /storage/tftpboot/master-path
    pxe_append_params: "console=tty0 console=ttyS0,115200 coreos.autologin=tty0"
    ipxe_boot_script: $pybasedir/drivers/modules/boot.ipxe
    ## to enable/disable ipxe, replace values of both following keys
    ipxe_enabled: false
    pxe_config_template: $pybasedir/drivers/modules/pxe_config.template
    # ipxe_enabled: true
    # pxe_config_template: $pybasedir/drivers/modules/ipxe_config.template

api:
  ## Ironic API container name
  ##
  name: api

  ## Ironic API scaling settings
  ##
  replicas: 1

  ## Ironic API ports
  ##
  portInternal: 8080
  portExternal: 6387

  ingress:
    ## @param ingress.enabled Enable ingress record generation for %%MAIN_CONTAINER_NAME%%
    ##
    enabled: true
    ## @param ingress.pathType Ingress path type
    ##
    pathType: ImplementationSpecific
    ## @param ingress.apiVersion Force Ingress API version (automatically detected if not set)
    ##
    apiVersion:
    ## @param ingress.hostname Default host for the ingress record
    ##
    hostname: ironic-api.local
    ## @param ingress.path Default path for the ingress record
    ## NOTE: You may need to set this to '/*' in order to use this with ALB ingress controllers
    ##
    path: /
    ## @param ingress.annotations Additional custom annotations for the ingress record
    ## NOTE: If `ingress.certManager=true`, annotation `kubernetes.io/tls-acme: "true"` will automatically be added
    ##
    annotations: {}
    ## @param ingress.tls Enable TLS configuration for the host defined at `ingress.hostname` parameter
    ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
    ## You can:
    ##   - Use the `ingress.secrets` parameter to create this TLS secret
    ##   - Relay on cert-manager to create it by setting `ingress.certManager=true`
    ##   - Relay on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
    ##
    tls: false
    ## @param ingress.certManager Add the corresponding annotations for cert-manager integration
    ##
    certManager: false
    ## @param ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
    ##
    selfSigned: false
    ## @param ingress.extraHosts An array with additional hostname(s) to be covered with the ingress record
    ## e.g:
    ## extraHosts:
    ##   - name: ironic-api.local
    ##     path: /
    ##
    extraHosts: []
    ## @param ingress.extraPaths An array with additional arbitrary paths that may need to be added to the ingress under the main host
    ## e.g:
    ## extraPaths:
    ## - path: /*
    ##   backend:
    ##     serviceName: ssl-redirect
    ##     servicePort: use-annotation
    ##
    extraPaths: []
    ## @param ingress.extraTls TLS configuration for additional hostname(s) to be covered with this ingress record
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    ## e.g:
    ## extraTls:
    ## - hosts:
    ##     - ironic-api.local
    ##   secretName: ironic-api.local-tls
    ##
    extraTls: []
    ## @param ingress.secrets Custom TLS certificates as secrets
    ## NOTE: 'key' and 'certificate' are expected in PEM format
    ## NOTE: 'name' should line up with a 'secretName' set further up
    ## If it is not set and you're using cert-manager, this is unneeded, as it will create a secret for you with valid certificates
    ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created valid for 365 days
    ## It is also possible to create and manage the certificates outside of this helm chart
    ## Please see README.md for more information
    ## e.g:
    ## secrets:
    ##   - name: ironic-api.local-tls
    ##     key: |-
    ##       -----BEGIN RSA PRIVATE KEY-----
    ##       ...
    ##       -----END RSA PRIVATE KEY-----
    ##     certificate: |-
    ##       -----BEGIN CERTIFICATE-----
    ##       ...
    ##       -----END CERTIFICATE-----
    ##
    secrets: []
    
  # K8S service types
  # For service type ClusterIP define externalIPs
  service_type: ClusterIP
  # externalIPs:
  #   - DEFINE-IP-HERE

  # For service type LoadBalancer define loadBalancerIP
  # service_type: LoadBalancer
  # loadBalancerIP: DEFINE-IP-HERE

  # Optional service annotations
  # service_annotations:
  #   metallb.universe.tf/allow-shared-ip: sharing key

  ## Ironic API resources
  ##
  resources:
    requests:
      memory: "8G"
      cpu: "8"
    limits:
      memory: "8G"
      cpu: "8"

keystone:
  enabled: false
  ## Keystone container name
  ##
  name: keystone

  default_region: ironic

  ## Keystone scaling settings
  ##
  replicas: 1

  ## Ironic API ports
  ##
  portInternal: 5000
  portExternal: 5000

  ingress:
    ## @param ingress.enabled Enable ingress record generation for %%MAIN_CONTAINER_NAME%%
    ##
    enabled: false
    ## @param ingress.pathType Ingress path type
    ##
    pathType: ImplementationSpecific
    ## @param ingress.apiVersion Force Ingress API version (automatically detected if not set)
    ##
    apiVersion:
    ## @param ingress.hostname Default host for the ingress record
    ##
    hostname: ironic-keystone.local
    ## @param ingress.path Default path for the ingress record
    ## NOTE: You may need to set this to '/*' in order to use this with ALB ingress controllers
    ##
    path: /
    ## @param ingress.annotations Additional custom annotations for the ingress record
    ## NOTE: If `ingress.certManager=true`, annotation `kubernetes.io/tls-acme: "true"` will automatically be added
    ##
    annotations: {}
    ## @param ingress.tls Enable TLS configuration for the host defined at `ingress.hostname` parameter
    ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
    ## You can:
    ##   - Use the `ingress.secrets` parameter to create this TLS secret
    ##   - Relay on cert-manager to create it by setting `ingress.certManager=true`
    ##   - Relay on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
    ##
    tls: false
    ## @param ingress.certManager Add the corresponding annotations for cert-manager integration
    ##
    certManager: false
    ## @param ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
    ##
    selfSigned: false
    ## @param ingress.extraHosts An array with additional hostname(s) to be covered with the ingress record
    ## e.g:
    ## extraHosts:
    ##   - name: ironic-keystone.local
    ##     path: /
    ##
    extraHosts: []
    ## @param ingress.extraPaths An array with additional arbitrary paths that may need to be added to the ingress under the main host
    ## e.g:
    ## extraPaths:
    ## - path: /*
    ##   backend:
    ##     serviceName: ssl-redirect
    ##     servicePort: use-annotation
    ##
    extraPaths: []
    ## @param ingress.extraTls TLS configuration for additional hostname(s) to be covered with this ingress record
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    ## e.g:
    ## extraTls:
    ## - hosts:
    ##     - ironic-keystone.local
    ##   secretName: ironic-keystone.local-tls
    ##
    extraTls: []
    ## @param ingress.secrets Custom TLS certificates as secrets
    ## NOTE: 'key' and 'certificate' are expected in PEM format
    ## NOTE: 'name' should line up with a 'secretName' set further up
    ## If it is not set and you're using cert-manager, this is unneeded, as it will create a secret for you with valid certificates
    ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created valid for 365 days
    ## It is also possible to create and manage the certificates outside of this helm chart
    ## Please see README.md for more information
    ## e.g:
    ## secrets:
    ##   - name: ironic-keystone.local-tls
    ##     key: |-
    ##       -----BEGIN RSA PRIVATE KEY-----
    ##       ...
    ##       -----END RSA PRIVATE KEY-----
    ##     certificate: |-
    ##       -----BEGIN CERTIFICATE-----
    ##       ...
    ##       -----END CERTIFICATE-----
    ##
    secrets: []

  # K8S service types
  # For service type ClusterIP define externalIPs
  service_type: ClusterIP
  # externalIPs:
  #   - DEFINE-IP-HERE

  # For service type LoadBalancer define loadBalancerIP
  # service_type: LoadBalancer
  # loadBalancerIP: DEFINE-IP-HERE

  # Optional service annotations
  # service_annotations:
  #   metallb.universe.tf/allow-shared-ip: sharing key

  ## Ironic API resources
  ##
  resources:
    requests:
      memory: "128Mi"
      cpu: "200m"
    limits:
      memory: "256Mi"
      cpu: "1"

waitForDB:
  # The image for the wait-for-mariadb pod
  name: docker.io/bitnami/mariadb
  version: 10.5.11-debian-10-r0

httpboot:
  enabled: true
  ## Ironic www name
  ##
  name: httpboot

  ## Ironic www scaling
  ##
  replicas: 1

  portInternal: 80
  portExternal: 80

  ingress:
    ## @param ingress.enabled Enable ingress record generation for %%MAIN_CONTAINER_NAME%%
    ##
    enabled: false
    ## @param ingress.pathType Ingress path type
    ##
    pathType: ImplementationSpecific
    ## @param ingress.apiVersion Force Ingress API version (automatically detected if not set)
    ##
    apiVersion:
    ## @param ingress.hostname Default host for the ingress record
    ##
    hostname: ironic-httpboot.local
    ## @param ingress.path Default path for the ingress record
    ## NOTE: You may need to set this to '/*' in order to use this with ALB ingress controllers
    ##
    path: /
    ## @param ingress.annotations Additional custom annotations for the ingress record
    ## NOTE: If `ingress.certManager=true`, annotation `kubernetes.io/tls-acme: "true"` will automatically be added
    ##
    annotations:
      nginx.ingress.kubernetes.io/proxy-body-size: "0"
    ## @param ingress.tls Enable TLS configuration for the host defined at `ingress.hostname` parameter
    ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
    ## You can:
    ##   - Use the `ingress.secrets` parameter to create this TLS secret
    ##   - Relay on cert-manager to create it by setting `ingress.certManager=true`
    ##   - Relay on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
    ##
    tls: false
    ## @param ingress.certManager Add the corresponding annotations for cert-manager integration
    ##
    certManager: false
    ## @param ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
    ##
    selfSigned: false
    ## @param ingress.extraHosts An array with additional hostname(s) to be covered with the ingress record
    ## e.g:
    ## extraHosts:
    ##   - name: ironic-httpboot.local
    ##     path: /
    ##
    extraHosts: []
    ## @param ingress.extraPaths An array with additional arbitrary paths that may need to be added to the ingress under the main host
    ## e.g:
    ## extraPaths:
    ## - path: /*
    ##   backend:
    ##     serviceName: ssl-redirect
    ##     servicePort: use-annotation
    ##
    extraPaths: []
    ## @param ingress.extraTls TLS configuration for additional hostname(s) to be covered with this ingress record
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    ## e.g:
    ## extraTls:
    ## - hosts:
    ##     - ironic-httpboot.local
    ##   secretName: ironic-httpboot.local-tls
    ##
    extraTls: []
    ## @param ingress.secrets Custom TLS certificates as secrets
    ## NOTE: 'key' and 'certificate' are expected in PEM format
    ## NOTE: 'name' should line up with a 'secretName' set further up
    ## If it is not set and you're using cert-manager, this is unneeded, as it will create a secret for you with valid certificates
    ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created valid for 365 days
    ## It is also possible to create and manage the certificates outside of this helm chart
    ## Please see README.md for more information
    ## e.g:
    ## secrets:
    ##   - name: ironic-httpboot.local-tls
    ##     key: |-
    ##       -----BEGIN RSA PRIVATE KEY-----
    ##       ...
    ##       -----END RSA PRIVATE KEY-----
    ##     certificate: |-
    ##       -----BEGIN CERTIFICATE-----
    ##       ...
    ##       -----END CERTIFICATE-----
    ##
    secrets: []

  # K8S service types
  # For service type ClusterIP define externalIPs
  service_type: ClusterIP
  # externalIPs:
  #   - DEFINE-IP-HERE

  # For service type LoadBalancer define loadBalancerIP
  # service_type: LoadBalancer
  # loadBalancerIP: DEFINE-IP-HERE

  # Optional service annotations
  # service_annotations:
  #   metallb.universe.tf/allow-shared-ip: sharing key

  ## Ironic www container image info
  ##
  image:
    name: nginx
    version: 1.13.5-alpine
    pullPolicy: IfNotPresent

  ## Ironic www resources
  ##
  resources:
    requests:
      memory: "2G"
      cpu: "2"
    limits:
      memory: "4G"
      cpu: "4"

mgmt:
  enabled: true

  ## Ironic management pod name
  ##
  name: mgmt

  ## Ironic management pod scaling
  ##
  replicas: 1

  ## POD Startup Command
  ##
  pod_command: /usr/bin/sleep
  pod_args: infinity

  ## POD Environment variables
  ##
  extra_env:
  - name: HISTFILE
    value: /mnt/mgmt-scripts/.bash_history

tftp:
  enabled: true

  ## Ironic tftp name
  ##
  name: tftp

  ## Ironic tftp network configuration
  ##
  # Note that tftp traffic is not managed by k8s
  # tfp daemons run on all worker node with hostNetwork=true
  # You can select either an ip of one of your k8s worker nodes,
  # or use a floating ip managed by metallb/keepalived
  public_ip: DEFINE-IP-HERE

  persistence:
    enabled: true
    accessMode: ReadWriteMany
    size: 8Gi
    annotations: {}
  ## make sure the resulted pvc can be cross mounted between the containers
  #  storageClass: "default"

  ## Ironic tftp resources
  ##
  resources:
    requests:
      memory: "2G"
      cpu: "2"
    limits:
      memory: "4G"
      cpu: "4"

  nodeSelector: {}

conductor:
  ## Ironic Conductor name
  ##
  name: conductor

  ## Ironic Conductor scaling
  ##
  replicas: 1

  ## Conductor can be run in privileged mode for iscsi deployment interface
  ##
  privileged: false
  hostNetwork: false

  ## Ironic Conductor resources
  ##
  resources:
    requests:
      memory: "8G"
      cpu: "8"
    limits:
      memory: "8G"
      cpu: "8"

mariadb:
  enabled: true
  auth:
    username: ironic
    database: ironic
    #password: setme
    #rootPassword: setmealso
  secondary:
    replicaCount: 0
  primary:
    persistence:
      enabled: true
  resources:
    requests:
      memory: 256Mi
      cpu: 100m
  metrics:
    enabled: true

## If the MariaDB database included in the chart is disabled, Ironic will
## use below parameters to connect to an external MariaDB/MySQL server.
##    
externalDatabase:
  ## @param externalDatabase.host Host of the external database
  ##
  host: localhost
  ## @param externalDatabase.user Existing username in the external db
  ##
  user: ironic
  ## @param externalDatabase.password Password for the above username
  ##
  password: ''
  ## @param externalDatabase.rootpassword Password for the above username
  ##
  rootPassword: ''
  ## @param externalDatabase.port Port of the external database
  ##
  port: 3306
  ## @param externalDatabase.sslmode External database ssl mode
  ##
  sslmode: disable
  ## @param externalDatabase.name External database name
  ##
  name:


rabbitmq:
  enabled: true
  replicas: 1
  auth:
    username: rabbitmq
#    password: DEFINE-THIS-SECRET
#    erlangCookie: DEFINE-THIS-SECRET
  persistence:
    enabled: false
## If the RabbitMQ database included in the chart is disabled, Ironic will
## use below parameters to connect to an external RabbitMQ server.
##    
externalRabbitmq:
  ## @param externalRabbitmq.host Host of the external Rabbitmq
  ##
  host: localhost
  ## @param externalRabbitmq.user Existing username in the external db
  ##
  user: ironic
  ## @param externalRabbitmq.password Password for the above username
  ##
  password: ''
  ## @param externalRabbitmq.erlangCookie Password for the above username
  ##
  erlangCookie: ''
  ## @param externalRabbitmq.port Port of the external Rabbitmq
  ##
  port: 5672
  ## @param externalRabbitmq.sslmode External Rabbitmq ssl mode
  ##
  sslmode: disable
  ## @param externalRabbitmq.name External Rabbitmq name
  ##
  name:
